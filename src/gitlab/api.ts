/**
 * GitLab API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 3
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import request = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://gitlab.com/api/v3';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class Branch {
    'name': string;
    'commit': BranchCommit;
    'protected': boolean;
}

export class BranchCommit {
    'id': string;
    'parents': Array<string>;
    'tree': string;
    'message': string;
    'author': BranchCommitAuthor;
    'committer': BranchCommitAuthor;
    'authoredDate': string;
    'committedDate': string;
}

export class BranchCommitAuthor {
    'name': string;
    'email': string;
}

export class Commit {
    'id': string;
    'message': string;
}

export class Group {
    'id': number;
    'name': string;
    'path': string;
    'description': string;
}

export class MergeRequest {
    'id': number;
    'iid': number;
    'targetBranch': string;
    'sourceBranch': string;
    'projectId': number;
    'title': string;
    'state': string;
    'upvotes': number;
    'downvotes': number;
    'author': MergeRequestAuthor;
    'assignee': MergeRequestAuthor;
    'sourceProjectId': number;
    'targetProjectId': number;
    'labels': Array<string>;
    'description': string;
    'workInProgress': boolean;
    'milestone': MergeRequestMilestone;
    'mergeWhenBuildSucceeds': boolean;
    'mergeStatus': string;
    'subscribed': boolean;
    'userNotesCount': number;
}

export class MergeRequestAuthor {
    'id': number;
    'username': string;
    'email': string;
    'name': string;
    'state': string;
    'createdAt': string;
}

export class MergeRequestMilestone {
    'id': number;
    'iid': number;
    'projectId': number;
    'title': string;
    'description': string;
    'state': string;
    'createdAt': string;
    'updatedAt': string;
    'dueDate': string;
}

export class Project {
    'id': number;
    'description': string;
    'defaultBranch': string;
    'public': boolean;
    'visibilityLevel': number;
    'sshUrlToRepo': string;
    'httpUrlToRepo': string;
    'webUrl': string;
    'tagList': Array<string>;
    'owner': ProjectOwner;
    'name': string;
    'nameWithNamespace': string;
    'path': string;
    'pathWithNamespace': string;
    'issuesEnabled': boolean;
    'mergeRequestsEnabled': boolean;
    'buildsEnabled': boolean;
    'wikiEnabled': boolean;
    'snippetsEnabled': boolean;
    'createdAt': string;
    'lastActivityAt': string;
    'creatorId': number;
    'namespace': ProjectNamespace;
    'archived': boolean;
    'avatarUrl': string;
}

export class ProjectNamespace {
    'createdAt': string;
    'description': string;
    'id': number;
    'name': string;
    'ownerId': number;
    'path': string;
    'updatedAt': string;
}

export class ProjectOwner {
    'id': number;
    'name': string;
    'createdAt': string;
}

export class Snippets {
    'id': number;
    'title': string;
    'file_name': string;
    'author': SnippetsAuthor;
    'updatedAt': string;
    'createdAt': string;
    'expiresAt': string;
    'web_url': string;
}

export class SnippetsAuthor {
    'name': string;
    'username': string;
    'id': number;
    'avatarUrl': string;
    'webUrl': string;
}

export class Tag {
    'name': string;
    'commit': Commit;
}


export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header") {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        // Do nothing
    }
}

export enum GroupsApiApiKeys {
    privateTokenHeader,
    privateTokenQuery,
}

export class GroupsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'privateTokenHeader': new ApiKeyAuth('header', 'PRIVATE-TOKEN'),
        'privateTokenQuery': new ApiKeyAuth('query', 'private_token'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: GroupsApiApiKeys, value: string) {
        this.authentications[GroupsApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[<string>key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * List a group&#39;s projects
     * Get a list of projects in this group.
     * @param id 
     * @param archived if passed, limit by archived status
     * @param visibility if passed, limit by visibility &#x60;public&#x60;, &#x60;internal&#x60;, &#x60;private&#x60;
     * @param orderBy Return requests ordered by &#x60;id&#x60;, &#x60;name&#x60;, &#x60;path&#x60;, &#x60;created_at&#x60;, &#x60;updated_at&#x60; or &#x60;last_activity_at&#x60; fields. Default is &#x60;created_at
     * @param sort Return requests sorted in &#x60;asc&#x60; or &#x60;desc&#x60; order. Default is &#x60;desc&#x60;
     * @param search Return list of authorized projects according to a search criteria
     * @param ciEnabledFirst Return projects ordered by ci_enabled flag. Projects with enabled GitLab CI go first
     */
    public listGroupProjects (id: string, archived?: boolean, visibility?: string, orderBy?: string, sort?: string, search?: string, ciEnabledFirst?: boolean) : Promise<{ response: http.ClientResponse; body: Array<Project>;  }> {
        const localVarPath = this.basePath + '/groups/{id}/projects'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling listGroupProjects.');
        }

        if (archived !== undefined) {
            queryParameters['archived'] = archived;
        }

        if (visibility !== undefined) {
            queryParameters['visibility'] = visibility;
        }

        if (orderBy !== undefined) {
            queryParameters['order_by'] = orderBy;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (ciEnabledFirst !== undefined) {
            queryParameters['ci_enabled_first'] = ciEnabledFirst;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.privateTokenQuery.applyToRequest(requestOptions);

        this.authentications.privateTokenHeader.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Project>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List groups
     * Get a list of groups. (As user: my groups, as admin: all groups)
     */
    public listGroups () : Promise<{ response: http.ClientResponse; body: Array<Group>;  }> {
        const localVarPath = this.basePath + '/groups';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.privateTokenQuery.applyToRequest(requestOptions);

        this.authentications.privateTokenHeader.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Group>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MergeRequestsApiApiKeys {
    privateTokenHeader,
    privateTokenQuery,
}

export class MergeRequestsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'privateTokenHeader': new ApiKeyAuth('header', 'PRIVATE-TOKEN'),
        'privateTokenQuery': new ApiKeyAuth('query', 'private_token'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: MergeRequestsApiApiKeys, value: string) {
        this.authentications[MergeRequestsApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[<string>key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Accept MR
     * Merge changes submitted with MR using this API. If the merge succeeds you&#39;ll get a 200 OK. If it has some conflicts and can not be merged - you&#39;ll get a 405 and the error message &#39;Branch cannot be merged&#39; If merge request is already merged or closed - you&#39;ll get a 406 and the error message &#39;Method Not Allowed&#39; If the sha parameter is passed and does not match the HEAD of the source - you&#39;ll get a 409 and the error message &#39;SHA does not match HEAD of source branch&#39; If you don&#39;t have permissions to accept this merge request - you&#39;ll get a 401 
     * @param id The ID of a project
     * @param mergeRequestId ID of MR
     */
    public acceptMergeRequest (id: string, mergeRequestId: number) : Promise<{ response: http.ClientResponse; body: MergeRequest;  }> {
        const localVarPath = this.basePath + '/projects/{id}/merge_requests/{merge_request_id}/merge'
            .replace('{' + 'id' + '}', String(id))
            .replace('{' + 'merge_request_id' + '}', String(mergeRequestId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling acceptMergeRequest.');
        }

        // verify required parameter 'mergeRequestId' is not null or undefined
        if (mergeRequestId === null || mergeRequestId === undefined) {
            throw new Error('Required parameter mergeRequestId was null or undefined when calling acceptMergeRequest.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.privateTokenQuery.applyToRequest(requestOptions);

        this.authentications.privateTokenHeader.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: MergeRequest;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create MR
     * Creates a new merge request.
     * @param id The ID of a project
     * @param sourceBranch The source branch
     * @param targetBranch The target branch
     * @param title Title of MR
     * @param assigneeId Assignee user ID
     * @param description Description of MR
     * @param targetProjectId The target project (numeric id)
     * @param labels Labels for MR as a comma-separated list
     * @param milestoneId Milestone ID
     */
    public createMergeRequest (id: string, sourceBranch: string, targetBranch: string, title: string, assigneeId?: number, description?: string, targetProjectId?: number, labels?: Array<string>, milestoneId?: number) : Promise<{ response: http.ClientResponse; body: MergeRequest;  }> {
        const localVarPath = this.basePath + '/projects/{id}/merge_requests'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling createMergeRequest.');
        }

        // verify required parameter 'sourceBranch' is not null or undefined
        if (sourceBranch === null || sourceBranch === undefined) {
            throw new Error('Required parameter sourceBranch was null or undefined when calling createMergeRequest.');
        }

        // verify required parameter 'targetBranch' is not null or undefined
        if (targetBranch === null || targetBranch === undefined) {
            throw new Error('Required parameter targetBranch was null or undefined when calling createMergeRequest.');
        }

        // verify required parameter 'title' is not null or undefined
        if (title === null || title === undefined) {
            throw new Error('Required parameter title was null or undefined when calling createMergeRequest.');
        }

        if (sourceBranch !== undefined) {
            queryParameters['source_branch'] = sourceBranch;
        }

        if (targetBranch !== undefined) {
            queryParameters['target_branch'] = targetBranch;
        }

        if (assigneeId !== undefined) {
            queryParameters['assignee_id'] = assigneeId;
        }

        if (title !== undefined) {
            queryParameters['title'] = title;
        }

        if (description !== undefined) {
            queryParameters['description'] = description;
        }

        if (targetProjectId !== undefined) {
            queryParameters['target_project_id'] = targetProjectId;
        }

        if (labels !== undefined) {
            queryParameters['labels'] = labels;
        }

        if (milestoneId !== undefined) {
            queryParameters['milestone_id'] = milestoneId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.privateTokenQuery.applyToRequest(requestOptions);

        this.authentications.privateTokenHeader.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: MergeRequest;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List merge requests
     * Get all merge requests for this project. The state parameter can be used to get only merge requests with a given state (&#x60;opened&#x60;, &#x60;closed&#x60;, or &#x60;merged&#x60;) or all of them (&#x60;all&#x60;). The pagination parameters &#x60;page&#x60; and &#x60;per_page&#x60; can be used to restrict the list of merge requests.
     * @param id The ID of a project
     * @param iid Return the request having the given &#x60;iid&#x60;
     * @param state Return &#x60;all&#x60; requests or just those that are &#x60;merged&#x60;, &#x60;opened&#x60; or &#x60;closed&#x60;
     * @param orderBy Return requests ordered by &#x60;created_at&#x60; or &#x60;updated_at&#x60; fields. Default is &#x60;created_at&#x60;
     * @param sort Return requests sorted in &#x60;asc&#x60; or &#x60;desc&#x60; order. Default is &#x60;desc&#x60;
     */
    public listMergeRequests (id: string, iid?: number, state?: string, orderBy?: string, sort?: string) : Promise<{ response: http.ClientResponse; body: Array<MergeRequest>;  }> {
        const localVarPath = this.basePath + '/projects/{id}/merge_requests'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling listMergeRequests.');
        }

        if (iid !== undefined) {
            queryParameters['iid'] = iid;
        }

        if (state !== undefined) {
            queryParameters['state'] = state;
        }

        if (orderBy !== undefined) {
            queryParameters['order_by'] = orderBy;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.privateTokenQuery.applyToRequest(requestOptions);

        this.authentications.privateTokenHeader.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<MergeRequest>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update MR
     * Updates an existing merge request. You can change the target branch, title, or even close the MR.
     * @param id The ID of a project
     * @param mergeRequestId ID of MR
     * @param title Title of MR
     * @param targetBranch The target branch
     * @param assigneeId Assignee user ID
     * @param description Description of MR
     * @param stateEvent New state (close|reopen|merge)
     * @param labels Labels for MR as a comma-separated list
     * @param milestoneId Milestone ID
     */
    public updateMergeRequest (id: string, mergeRequestId: number, title: string, targetBranch?: string, assigneeId?: number, description?: string, stateEvent?: string, labels?: Array<string>, milestoneId?: number) : Promise<{ response: http.ClientResponse; body: MergeRequest;  }> {
        const localVarPath = this.basePath + '/projects/{id}/merge_requests/{merge_request_id}'
            .replace('{' + 'id' + '}', String(id))
            .replace('{' + 'merge_request_id' + '}', String(mergeRequestId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateMergeRequest.');
        }

        // verify required parameter 'mergeRequestId' is not null or undefined
        if (mergeRequestId === null || mergeRequestId === undefined) {
            throw new Error('Required parameter mergeRequestId was null or undefined when calling updateMergeRequest.');
        }

        // verify required parameter 'title' is not null or undefined
        if (title === null || title === undefined) {
            throw new Error('Required parameter title was null or undefined when calling updateMergeRequest.');
        }

        if (targetBranch !== undefined) {
            queryParameters['target_branch'] = targetBranch;
        }

        if (assigneeId !== undefined) {
            queryParameters['assignee_id'] = assigneeId;
        }

        if (title !== undefined) {
            queryParameters['title'] = title;
        }

        if (description !== undefined) {
            queryParameters['description'] = description;
        }

        if (stateEvent !== undefined) {
            queryParameters['state_event'] = stateEvent;
        }

        if (labels !== undefined) {
            queryParameters['labels'] = labels;
        }

        if (milestoneId !== undefined) {
            queryParameters['milestone_id'] = milestoneId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.privateTokenQuery.applyToRequest(requestOptions);

        this.authentications.privateTokenHeader.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: MergeRequest;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ProjectApiApiKeys {
    privateTokenHeader,
    privateTokenQuery,
}

export class ProjectApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'privateTokenHeader': new ApiKeyAuth('header', 'PRIVATE-TOKEN'),
        'privateTokenQuery': new ApiKeyAuth('query', 'private_token'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ProjectApiApiKeys, value: string) {
        this.authentications[ProjectApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[<string>key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get single project
     * Get a specific project, identified by project ID or NAMESPACE/PROJECT_NAME, which is owned by the authenticated user. If using namespaced projects call make sure that the NAMESPACE/PROJECT_NAME is URL-encoded, eg. /api/v3/projects/diaspora%2Fdiaspora (where / is represented by %2F).
     * @param id The ID or NAMESPACE/PROJECT_NAME of a project
     */
    public getProject (id: string) : Promise<{ response: http.ClientResponse; body: Project;  }> {
        const localVarPath = this.basePath + '/projects/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProject.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.privateTokenQuery.applyToRequest(requestOptions);

        this.authentications.privateTokenHeader.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Project;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List branches
     * Lists all branches of a project.
     * @param id The ID or NAMESPACE/PROJECT_NAME of a project
     */
    public listBranches (id: string) : Promise<{ response: http.ClientResponse; body: Array<Branch>;  }> {
        const localVarPath = this.basePath + '/projects/{id}/repository/branches'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling listBranches.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.privateTokenQuery.applyToRequest(requestOptions);

        this.authentications.privateTokenHeader.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Branch>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List projects
     * Get a list of projects for which the authenticated user is a member.
     * @param archived if passed, limit by archived status
     * @param visibility if passed, limit by visibility &#x60;public&#x60;, &#x60;internal&#x60;, &#x60;private&#x60;
     * @param orderBy Return projects ordered by &#x60;id&#x60;, &#x60;name&#x60;, &#x60;path&#x60;, &#x60;created_at&#x60;, &#x60;updated_at&#x60;, or &#x60;last_activity_at&#x60; fields. Default is &#x60;created_at&#x60;
     * @param sort Return projects sorted in &#x60;asc&#x60; or &#x60;desc&#x60; order. Default is &#x60;desc&#x60;
     * @param search Return list of authorized projects matching the search criteria
     * @param simple Return only the ID, URL, name, and path of each project
     */
    public listProjects (archived?: boolean, visibility?: string, orderBy?: string, sort?: string, search?: string, simple?: boolean) : Promise<{ response: http.ClientResponse; body: Array<Project>;  }> {
        const localVarPath = this.basePath + '/projects';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (archived !== undefined) {
            queryParameters['archived'] = archived;
        }

        if (visibility !== undefined) {
            queryParameters['visibility'] = visibility;
        }

        if (orderBy !== undefined) {
            queryParameters['order_by'] = orderBy;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (simple !== undefined) {
            queryParameters['simple'] = simple;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.privateTokenQuery.applyToRequest(requestOptions);

        this.authentications.privateTokenHeader.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Project>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SnippetsApiApiKeys {
    privateTokenHeader,
    privateTokenQuery,
}

export class SnippetsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'privateTokenHeader': new ApiKeyAuth('header', 'PRIVATE-TOKEN'),
        'privateTokenQuery': new ApiKeyAuth('query', 'private_token'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: SnippetsApiApiKeys, value: string) {
        this.authentications[SnippetsApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[<string>key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Create Snippet
     * Creates a new project snippet. The user must have permission to create new snippets.
     * @param id The ID of a project
     * @param title The title of a snippet
     * @param fileName The name of a snippet file
     * @param code The content of a snippet
     * @param visibilityLevel The snippet&#39;s visibility
     */
    public createSnippet (id: number, title: string, fileName: string, code: string, visibilityLevel: number) : Promise<{ response: http.ClientResponse; body: Snippets;  }> {
        const localVarPath = this.basePath + '/projects/{id}/snippets'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling createSnippet.');
        }

        // verify required parameter 'title' is not null or undefined
        if (title === null || title === undefined) {
            throw new Error('Required parameter title was null or undefined when calling createSnippet.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling createSnippet.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling createSnippet.');
        }

        // verify required parameter 'visibilityLevel' is not null or undefined
        if (visibilityLevel === null || visibilityLevel === undefined) {
            throw new Error('Required parameter visibilityLevel was null or undefined when calling createSnippet.');
        }

        if (title !== undefined) {
            queryParameters['title'] = title;
        }

        if (fileName !== undefined) {
            queryParameters['file_name'] = fileName;
        }

        if (code !== undefined) {
            queryParameters['code'] = code;
        }

        if (visibilityLevel !== undefined) {
            queryParameters['visibility_level'] = visibilityLevel;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.privateTokenQuery.applyToRequest(requestOptions);

        this.authentications.privateTokenHeader.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Snippets;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete Snippet
     * Deletes an existing project snippet.
     * @param id The ID of a project
     * @param snippetId The ID of a project&#39;s snippet
     */
    public deleteSnippet (id: number, snippetId: number) : Promise<{ response: http.ClientResponse; body: Snippets;  }> {
        const localVarPath = this.basePath + '/projects/{id}/snippets/{snippet_id}'
            .replace('{' + 'id' + '}', String(id))
            .replace('{' + 'snippet_id' + '}', String(snippetId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteSnippet.');
        }

        // verify required parameter 'snippetId' is not null or undefined
        if (snippetId === null || snippetId === undefined) {
            throw new Error('Required parameter snippetId was null or undefined when calling deleteSnippet.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.privateTokenQuery.applyToRequest(requestOptions);

        this.authentications.privateTokenHeader.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Snippets;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Single Snippet
     * Get a single project snippet.
     * @param id The ID of a project
     * @param snippetId The ID of a project&#39;s snippet
     */
    public getSnippet (id: number, snippetId: number) : Promise<{ response: http.ClientResponse; body: Snippets;  }> {
        const localVarPath = this.basePath + '/projects/{id}/snippets/{snippet_id}'
            .replace('{' + 'id' + '}', String(id))
            .replace('{' + 'snippet_id' + '}', String(snippetId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSnippet.');
        }

        // verify required parameter 'snippetId' is not null or undefined
        if (snippetId === null || snippetId === undefined) {
            throw new Error('Required parameter snippetId was null or undefined when calling getSnippet.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.privateTokenQuery.applyToRequest(requestOptions);

        this.authentications.privateTokenHeader.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Snippets;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Snippet content
     * Returns the raw project snippet as plain text.
     * @param id The ID of a project
     * @param snippetId The ID of a project&#39;s snippet
     */
    public getSnippetContent (id: number, snippetId: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/projects/{id}/snippets/{snippet_id}/raw'
            .replace('{' + 'id' + '}', String(id))
            .replace('{' + 'snippet_id' + '}', String(snippetId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSnippetContent.');
        }

        // verify required parameter 'snippetId' is not null or undefined
        if (snippetId === null || snippetId === undefined) {
            throw new Error('Required parameter snippetId was null or undefined when calling getSnippetContent.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.privateTokenQuery.applyToRequest(requestOptions);

        this.authentications.privateTokenHeader.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List snippets
     * Lists all snippets of a project.
     * @param id The ID of a project
     */
    public listSnippets (id: number) : Promise<{ response: http.ClientResponse; body: Array<Snippets>;  }> {
        const localVarPath = this.basePath + '/projects/{id}/snippets'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling listSnippets.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.privateTokenQuery.applyToRequest(requestOptions);

        this.authentications.privateTokenHeader.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Snippets>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Single Snippet
     * Get a single project snippet.
     * @param id The ID of a project
     * @param snippetId The ID of a project&#39;s snippet
     * @param title The title of a snippet
     * @param fileName The name of a snippet file
     * @param code The content of a snippet
     * @param visibilityLevel The snippet&#39;s visibility
     */
    public updateSnippet (id: number, snippetId: number, title?: string, fileName?: string, code?: string, visibilityLevel?: number) : Promise<{ response: http.ClientResponse; body: Snippets;  }> {
        const localVarPath = this.basePath + '/projects/{id}/snippets/{snippet_id}'
            .replace('{' + 'id' + '}', String(id))
            .replace('{' + 'snippet_id' + '}', String(snippetId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateSnippet.');
        }

        // verify required parameter 'snippetId' is not null or undefined
        if (snippetId === null || snippetId === undefined) {
            throw new Error('Required parameter snippetId was null or undefined when calling updateSnippet.');
        }

        if (title !== undefined) {
            queryParameters['title'] = title;
        }

        if (fileName !== undefined) {
            queryParameters['file_name'] = fileName;
        }

        if (code !== undefined) {
            queryParameters['code'] = code;
        }

        if (visibilityLevel !== undefined) {
            queryParameters['visibility_level'] = visibilityLevel;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.privateTokenQuery.applyToRequest(requestOptions);

        this.authentications.privateTokenHeader.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Snippets;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TagsApiApiKeys {
    privateTokenHeader,
    privateTokenQuery,
}

export class TagsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'privateTokenHeader': new ApiKeyAuth('header', 'PRIVATE-TOKEN'),
        'privateTokenQuery': new ApiKeyAuth('query', 'private_token'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: TagsApiApiKeys, value: string) {
        this.authentications[TagsApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[<string>key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * List project repository tags
     * Get a list of repository tags from a project, sorted by name in reverse alphabetical order.
     * @param id The ID or NAMESPACE/PROJECT_NAME of a project
     */
    public listTags (id: string) : Promise<{ response: http.ClientResponse; body: Array<Tag>;  }> {
        const localVarPath = this.basePath + '/projects/{id}/repository/tags'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling listTags.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.privateTokenQuery.applyToRequest(requestOptions);

        this.authentications.privateTokenHeader.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Tag>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
